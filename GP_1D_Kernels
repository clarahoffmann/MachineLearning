require(MASS)
require(ggplot2)
require(reshape2)
require(gridExtra)

setwd("...")

# observed values
x <- c(-4,-3, -2, -1 , 1)
y = sin(x)
x.star <- seq(-5,5,len=100) # x values for prediction 

# define all kernel functions
# Gaussian kernel
gaussKernel <- function(X1, X2 ,l=1, sigma.f = 1 ) {
  Zero <- matrix( rep( 0, len=length(X1)*length(X2)), nrow = length(X1))
  A <- Zero + X1
  B <- t(t(Zero)+X2)
  Sigma <- (sigma.f^2)*exp(-((A-B)^2)/(2*(l^2)))
  return(Sigma)
}
# Ornstein-Uhlenbeck kernel
ouKernel <- function(X1, X2) {
  Zero <- matrix( rep( 0, len=length(X1)*length(X2)), nrow = length(X1))
  A <- Zero + X1
  B <- t(t(Zero)+X2)
  Sigma <- exp(-(abs(A-B))/(1))
  return(Sigma)
}
# Periodic kernel
periodicKernel <- function(X1, X2) {
  Zero <- matrix( rep( 0, len=length(X1)*length(X2)), nrow = length(X1))
  A <- Zero + X1
  B <- t(t(Zero)+X2)
  Sigma <- exp(-2*((sin(A-B))^2)/(0.3^2))
  return(Sigma)
}
# Rational quadratic kernel
ratKernel <- function(X1, X2) {
  Zero <- matrix( rep( 0, len=length(X1)*length(X2)), nrow = length(X1))
  A <- Zero + X1
  B <- t(t(Zero)+X2)
  Sigma <- (1+((A-B)^2)/(5*1^2))^(-5)
  return(Sigma)
}
# Locally periodic kernel
locKernel <- function(X1, X2 ) {
  Zero <- matrix( rep( 0, len=length(X1)*length(X2)), nrow = length(X1))
  A <- Zero + X1
  B <- t(t(Zero)+X2)
  Sigma1 <- 1*exp(-((A-B)^2)/(2*(1)))
  Sigma2 <- exp(-2*((sin(A-B))^2)/(1))
  Sigma <- Sigma1*Sigma2
  return(Sigma)
}

myplot <- function(mykernel, X=x, X.star=x.star, Y = y){
  names <- c("gaussian", "ornstein-uhlenbeck", 
             "periodic","rational quadratic", 
             "locally periodic")
  var <- which(names %in% mykernel)
  kernel <- function(x, X1, X2){
    switch(var, 
           return(gaussKernel(X1, X2)),
           return(ouKernel(X1, X2)),
           return(periodicKernel(X1, X2)),
           return(ratKernel(X1, X2)),
           return(locKernel(X1, X2)))
  }  
    K <- kernel(var, X, X)
    K.star <- kernel(var, X, X.star) 
    K.star.star <- kernel(var, X.star, X.star) 
    postCov <- K.star.star - t(K.star)%*%solve(K)%*%K.star
    mu.star <- t(K.star)%*%solve(K)%*%y
    
    n.samples <- 6
    values <- matrix(rep(0,length(X.star)*n.samples), ncol=n.samples)
    for (i in 1:n.samples) {
      values[,i] <- mvrnorm(1, mu.star , postCov)
    }
    values <- cbind(x=X.star,as.data.frame(values))
    values <- melt(values,id="x")
    S2 <- diag(postCov)
    lowerbound <- mu.star +2*sqrt(S2)
    upperbound <- mu.star -2*sqrt(S2)
    graph <- ggplot() + 
      geom_ribbon(x = X.star, aes(ymin= lowerbound, 
                                  ymax = upperbound), fill = "grey70") +
      geom_point( data = NULL,aes( x = X, y=Y)) +
      geom_line(data = values, aes(x = x, y=value, 
                                   group=variable, colour = variable)) +
      theme(legend.position="none") +
      labs(title = paste(names[var])) +
      scale_y_continuous(limits=c(-3, 3))
    return(graph)  
}

gaussian <- myplot("gaussian")
ornstine <- myplot("ornstein-uhlenbeck")
periodic <- myplot("periodic")
rational <- myplot("rational quadratic")
locped <- myplot("locally periodic")

figure <- grid.arrange(gaussian, ornstine, periodic, rational, locped , nrow = 2)
figure
ggsave("gp_kernels.pdf", plot = figure ) # save
